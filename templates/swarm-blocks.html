<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>SwarmHub: –ü—Ä–∏–∫–ª–∞–¥–Ω—ã–µ –ó–∞–¥–∞—á–∏</title>
  <link rel="icon" href="../static/favicon.svg" type="image/x-icon">
  <link rel="stylesheet" href="../static/css/styles.css">
  <style>
    .swarm-blocks-grid-3 {
      display: grid;
      grid-template-columns: 1fr;
      gap: 1.5rem;
      margin-bottom: 1.5rem;
    }

    @media (min-width: 1024px) {
      .swarm-blocks-grid-3 {
        grid-template-columns: 1fr;
      }
    }

    .swarm-blocks-layout {
      display: grid;
      grid-template-columns: 1fr;
      gap: 1.5rem;
    }

    @media (min-width: 1280px) {
      .swarm-blocks-layout {
        grid-template-columns: 300px 1fr;
        gap: 1.5rem;
      }

      .swarm-blocks-sidebar {
        display: flex;
        flex-direction: column;
        gap: 1.5rem;
      }

      .swarm-blocks-main {
        display: flex;
        flex-direction: column;
        gap: 1.5rem;
      }
    }
  </style>
</head>
<body class="swarm-blocks-container">
  <div class="swarm-blocks-max-w">
    <header class="swarm-blocks-header">
      <h1 class="swarm-blocks-h1">SwarmHub: –ü—Ä–∏–∫–ª–∞–¥–Ω—ã–µ –ó–∞–¥–∞—á–∏</h1>
      <p class="swarm-blocks-subtitle">–†–µ—à–∞–π—Ç–µ —Ä–µ–∞–ª—å–Ω—ã–µ –ø—Ä–æ–±–ª–µ–º—ã —Å –ø–æ–º–æ—â—å—é —Ä–æ–µ–≤–æ–≥–æ –∏–Ω—Ç–µ–ª–ª–µ–∫—Ç–∞</p>
    </header>

    <div class="swarm-blocks-grid-3">
      <!-- –í—ã–±–æ—Ä –∑–∞–¥–∞—á–∏ -->
      <div class="swarm-blocks-card swarm-blocks-span-full">
        <h2 class="swarm-blocks-h2">–í—ã–±–µ—Ä–∏—Ç–µ –ø—Ä–∏–∫–ª–∞–¥–Ω—É—é –∑–∞–¥–∞—á—É</h2>
        <div class="swarm-blocks-task-grid" id="taskGrid"></div>
      </div>
    </div>

    <!-- –û—Å–Ω–æ–≤–Ω–æ–π –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä —Å –±–æ–∫–æ–≤–æ–π –ø–∞–Ω–µ–ª—å—é –∏ –≥–ª–∞–≤–Ω—ã–º —Å–æ–¥–µ—Ä–∂–∏–º—ã–º -->
    <div class="swarm-blocks-layout">
      <!-- –õ–µ–≤–∞—è –±–æ–∫–æ–≤–∞—è –ø–∞–Ω–µ–ª—å -->
      <div class="swarm-blocks-sidebar">
        <!-- –ë–ª–æ–∫–∏ –ø—Ä–∞–≤–∏–ª -->
        <div class="swarm-blocks-card">
          <h2 class="swarm-blocks-h2">–ë–ª–æ–∫–∏ –∞–ª–≥–æ—Ä–∏—Ç–º–æ–≤</h2>
          <div class="swarm-blocks-list" id="blocksList"></div>
        </div>

        <!-- –ê–∫—Ç–∏–≤–Ω—ã–µ –ø—Ä–∞–≤–∏–ª–∞ -->
        <div class="swarm-blocks-card">
          <h2 class="swarm-blocks-h2">–ü—Ä–æ–≥—Ä–∞–º–º–∞ (<span id="ruleCount">0</span>)</h2>
          <div class="swarm-blocks-list" id="rulesList"></div>
          <div class="swarm-blocks-hint" id="hint">üí° –ü–æ–¥—Å–∫–∞–∑–∫–∞ –∑–∞–≥—Ä—É–∂–∞–µ—Ç—Å—è...</div>
        </div>
      </div>

      <!-- –ì–ª–∞–≤–Ω–æ–µ —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ -->
      <div class="swarm-blocks-main">
        <!-- –°–∏–º—É–ª—è—Ü–∏—è -->
        <div class="swarm-blocks-card">
          <div class="swarm-blocks-controls">
            <h2 class="swarm-blocks-h2">–°–∏–º—É–ª—è—Ü–∏—è</h2>
            <div style="display: flex; gap: 0.5rem;">
              <button class="swarm-blocks-btn swarm-blocks-btn-play" id="playBtn" style="display:flex;">
                ‚ñ∂ –°—Ç–∞—Ä—Ç
              </button>
              <button class="swarm-blocks-btn swarm-blocks-btn-pause" id="pauseBtn" style="display:none;">
                ‚è∏ –ü–∞—É–∑–∞
              </button>
              <button class="swarm-blocks-btn swarm-blocks-btn-reset" id="resetBtn">
                ‚Üª –°–±—Ä–æ—Å
              </button>
            </div>
          </div>

          <div id="successMsg" class="swarm-blocks-success" style="display:none;">
            <span style="color: #22c55e; font-size: 1.5rem;">‚úì</span>
            <div class="swarm-blocks-success-content">
              <div class="swarm-blocks-success-title">–ó–∞–¥–∞—á–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–∞!</div>
              <div class="swarm-blocks-success-subtitle" id="successStats">–≠—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ—Å—Ç—å: 0.0 ‚Ä¢ –í—Ä–µ–º—è: 0—Å</div>
            </div>
          </div>

          <canvas id="simCanvas" class="swarm-blocks-canvas" width="800" height="600"></canvas>

          <div class="swarm-blocks-stats">
            <div class="swarm-blocks-stat-box">
              <div class="swarm-blocks-stat-label">–ê–≥–µ–Ω—Ç—ã</div>
              <div class="swarm-blocks-stat-value" id="agentCount">0</div>
            </div>
            <div class="swarm-blocks-stat-box">
              <div class="swarm-blocks-stat-label">–í—ã–ø–æ–ª–Ω–µ–Ω–æ</div>
              <div class="swarm-blocks-stat-value"><span id="collectedCount">0</span>/<span id="totalCount">0</span></div>
            </div>
            <div class="swarm-blocks-stat-box">
              <div class="swarm-blocks-stat-label">–ü–æ–∫—Ä—ã—Ç–∏–µ</div>
              <div class="swarm-blocks-stat-value"><span id="coverageValue">0</span>%</div>
            </div>
            <div class="swarm-blocks-stat-box">
              <div class="swarm-blocks-stat-label">–í—Ä–µ–º—è</div>
              <div class="swarm-blocks-stat-value"><span id="timeValue">0</span>—Å</div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- –ú–µ—Ç–æ–¥–∏—á–µ—Å–∫–∏–µ –º–∞—Ç–µ—Ä–∏–∞–ª—ã -->
    <div class="swarm-blocks-methodology">
      <div class="swarm-blocks-info-box blue">
        <h3>üéØ –¶–µ–ª–∏ –æ–±—É—á–µ–Ω–∏—è</h3>
        <ul>
          <li>‚Ä¢ –ü–æ–Ω–∏–º–∞–Ω–∏–µ –∞–ª–≥–æ—Ä–∏—Ç–º–∏—á–µ—Å–∫–æ–≥–æ –º—ã—à–ª–µ–Ω–∏—è</li>
          <li>‚Ä¢ –û—Å–Ω–æ–≤—ã –º–Ω–æ–≥–æ–∞–≥–µ–Ω—Ç–Ω—ã—Ö —Å–∏—Å—Ç–µ–º</li>
          <li>‚Ä¢ –ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ —Ä–æ–µ–≤–æ–≥–æ –∏–Ω—Ç–µ–ª–ª–µ–∫—Ç–∞</li>
          <li>‚Ä¢ –†–µ—à–µ–Ω–∏–µ –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–æ–Ω–Ω—ã—Ö –∑–∞–¥–∞—á</li>
          <li>‚Ä¢ –ö–æ–æ—Ä–¥–∏–Ω–∞—Ü–∏—è —Ä–∞—Å–ø—Ä–µ–¥–µ–ª—ë–Ω–Ω—ã—Ö —Å–∏—Å—Ç–µ–º</li>
        </ul>
      </div>

      <div class="swarm-blocks-info-box purple">
        <h3>üéì –ú–µ–∂–ø—Ä–µ–¥–º–µ—Ç–Ω—ã–µ —Å–≤—è–∑–∏</h3>
        <div style="font-size: 0.875rem; color: #cbd5e1;">
          <div style="margin-bottom: 0.25rem;"><strong>–ò–Ω—Ñ–æ—Ä–º–∞—Ç–∏–∫–∞:</strong> –∞–ª–≥–æ—Ä–∏—Ç–º—ã, –ò–ò, –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è</div>
          <div style="margin-bottom: 0.25rem;"><strong>–ú–∞—Ç–µ–º–∞—Ç–∏–∫–∞:</strong> –≤–µ–∫—Ç–æ—Ä—ã, —Ä–∞—Å—Å—Ç–æ—è–Ω–∏—è, —Ñ—É–Ω–∫—Ü–∏–∏</div>
          <div style="margin-bottom: 0.25rem;"><strong>–§–∏–∑–∏–∫–∞:</strong> –¥–≤–∏–∂–µ–Ω–∏–µ, —Å–∏–ª—ã, —Ç—Ä–∞–µ–∫—Ç–æ—Ä–∏–∏</div>
          <div style="margin-bottom: 0.25rem;"><strong>–ë–∏–æ–ª–æ–≥–∏—è:</strong> –ø–æ–≤–µ–¥–µ–Ω–∏–µ —Å—Ç–∞–π, —Ä–æ—ë–≤</div>
          <div style="margin-bottom: 0.25rem;"><strong>–û–ë–ñ:</strong> —Å–ø–∞—Å–∞—Ç–µ–ª—å–Ω—ã–µ –æ–ø–µ—Ä–∞—Ü–∏–∏</div>
          <div style="margin-bottom: 0.25rem;"><strong>–≠–∫–æ–ª–æ–≥–∏—è:</strong> –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥, –æ—á–∏—Å—Ç–∫–∞</div>
        </div>
      </div>
    </div>

    <!-- –õ–µ–≥–µ–Ω–¥–∞ -->
    <h3 class="swarm-blocks-h3">üó∫Ô∏è –õ–µ–≥–µ–Ω–¥–∞ –∫–∞—Ä—Ç—ã</h3>
    <div class="swarm-blocks-legend">
      <div class="swarm-blocks-legend-item">
        <div class="swarm-blocks-legend-color" style="background: rgba(34, 197, 94, 0.3); border: 2px solid #22c55e;"></div>
        <span>–ë–∞–∑–∞ / –°—Ç–∞—Ä—Ç</span>
      </div>
      <div class="swarm-blocks-legend-item">
        <div class="swarm-blocks-legend-color swarm-blocks-legend-circle" style="background: #ef4444;"></div>
        <span>–ö—Ä–∏—Ç–∏—á–µ—Å–∫–∏–µ —Ü–µ–ª–∏</span>
      </div>
      <div class="swarm-blocks-legend-item">
        <div class="swarm-blocks-legend-color" style="background: rgba(100, 100, 100, 0.4);"></div>
        <span>–ü—Ä–µ–ø—è—Ç—Å—Ç–≤–∏—è</span>
      </div>
      <div class="swarm-blocks-legend-item">
        <div class="swarm-blocks-legend-color swarm-blocks-legend-circle" style="background: linear-gradient(to right, #06b6d4, #c084fc);"></div>
        <span>–ê–≥–µ–Ω—Ç—ã —Ä–æ—è</span>
      </div>
    </div>

    <!-- –í—ã–∑–æ–≤—ã –∏ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è -->
    <h3 class="swarm-blocks-h3">üèÜ –ò—Å–ø—ã—Ç–∞–Ω–∏—è</h3>
    <div class="swarm-blocks-challenges">
      <div class="swarm-blocks-challenge-box">
        <div class="swarm-blocks-challenge-title">‚≠ê –ù–æ–≤–∏—á–æ–∫</div>
        <div class="swarm-blocks-challenge-desc">–†–µ—à–∏—Ç—å –∑–∞–¥–∞—á—É –ª—é–±—ã–º —Å–ø–æ—Å–æ–±–æ–º</div>
      </div>
      <div class="swarm-blocks-challenge-box">
        <div class="swarm-blocks-challenge-title">‚≠ê‚≠ê –≠–∫—Å–ø–µ—Ä—Ç</div>
        <div class="swarm-blocks-challenge-desc">–≠—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ—Å—Ç—å > 5.0</div>
      </div>
      <div class="swarm-blocks-challenge-box">
        <div class="swarm-blocks-challenge-title">‚≠ê‚≠ê‚≠ê –ú–∞—Å—Ç–µ—Ä</div>
        <div class="swarm-blocks-challenge-desc">–ú–∏–Ω–∏–º—É–º –±–ª–æ–∫–æ–≤, –º–∞–∫—Å–∏–º—É–º —Å–∫–æ—Ä–æ—Å—Ç–∏</div>
      </div>
    </div>

    <div class="swarm-blocks-footer">
      SwarmHub ¬© 2025 | –ö—É—Ä—Å–∫–∏–π –≥–æ—Å—É–¥–∞—Ä—Å—Ç–≤–µ–Ω–Ω—ã–π —É–Ω–∏–≤–µ—Ä—Å–∏—Ç–µ—Ç | –ò—Å—Å–ª–µ–¥–æ–≤–∞–Ω–∏–µ —Ä–æ–µ–≤–æ–≥–æ –∏–Ω—Ç–µ–ª–ª–µ–∫—Ç–∞
    </div>
  </div>

  <script>
    // –î–∞–Ω–Ω—ã–µ –æ –∑–∞–¥–∞—á–∞—Ö
    const tasks = {
      forest_fire: {
        name: 'üî• –¢—É—à–µ–Ω–∏–µ –ª–µ—Å–Ω–æ–≥–æ –ø–æ–∂–∞—Ä–∞',
        description: '–î—Ä–æ–Ω—ã-–ø–æ–∂–∞—Ä–Ω—ã–µ –¥–æ–ª–∂–Ω—ã –æ–±–Ω–∞—Ä—É–∂–∏—Ç—å –∏ –ø–æ—Ç—É—à–∏—Ç—å –≤—Å–µ –æ—á–∞–≥–∏ –≤–æ–∑–≥–æ—Ä–∞–Ω–∏—è',
        subject: '–û–ë–ñ / –≠–∫–æ–ª–æ–≥–∏—è',
        initialAgents: 6,
        agentType: 'drone',
        setupTargets: () => {
          return Array.from({ length: 12 }, () => ({
            x: Math.random() * 700 + 50,
            y: Math.random() * 500 + 50,
            type: 'fire',
            intensity: Math.random() * 50 + 50,
            extinguished: false
          }));
        },
        setupObstacles: () => {
          return Array.from({ length: 8 }, () => ({
            x: Math.random() * 700 + 50,
            y: Math.random() * 500 + 50,
            radius: 20
          }));
        },
        successCondition: (stats, targets) => {
          const extinguished = targets.filter(t => t.extinguished).length;
          return extinguished === targets.length;
        },
        hint: '–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ "–ù–∞–π—Ç–∏ –±–ª–∏–∂–∞–π—à—É—é —Ü–µ–ª—å" –∏ "–ò–∑–±–µ–≥–∞—Ç—å –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏–π"'
      },

      search_rescue: {
        name: 'üöÅ –ü–æ–∏—Å–∫–æ–≤–æ-—Å–ø–∞—Å–∞—Ç–µ–ª—å–Ω–∞—è –æ–ø–µ—Ä–∞—Ü–∏—è',
        description: '–í–µ—Ä—Ç–æ–ª—ë—Ç—ã –∏—â—É—Ç –ø–æ—Å—Ç—Ä–∞–¥–∞–≤—à–∏—Ö –≤ —Ç—Ä—É–¥–Ω–æ–¥–æ—Å—Ç—É–ø–Ω–æ–π –º–µ—Å—Ç–Ω–æ—Å—Ç–∏',
        subject: '–û–ë–ñ / –ì–µ–æ–≥—Ä–∞—Ñ–∏—è',
        initialAgents: 8,
        agentType: 'helicopter',
        setupTargets: () => {
          return Array.from({ length: 10 }, () => ({
            x: Math.random() * 700 + 50,
            y: Math.random() * 500 + 50,
            type: 'person',
            rescued: false,
            urgent: Math.random() > 0.7
          }));
        },
        setupObstacles: () => {
          return Array.from({ length: 15 }, () => ({
            x: Math.random() * 700 + 50,
            y: Math.random() * 500 + 50,
            radius: 15
          }));
        },
        successCondition: (stats, targets) => {
          const rescued = targets.filter(t => t.rescued).length;
          return rescued === targets.length;
        },
        hint: '–ö–æ–æ—Ä–¥–∏–Ω–∏—Ä—É–π—Ç–µ –¥–µ–π—Å—Ç–≤–∏—è: "–î–µ—Ä–∂–∞—Ç—å—Å—è –≤–º–µ—Å—Ç–µ" + "–ò–∑–±–µ–≥–∞—Ç—å –¥—Ä—É–≥–∏—Ö" –¥–ª—è –ø–æ–∫—Ä—ã—Ç–∏—è –±–æ–ª—å—à–µ–π –ø–ª–æ—â–∞–¥–∏'
      },

      warehouse: {
        name: 'üì¶ –ê–≤—Ç–æ–º–∞—Ç–∏–∑–∞—Ü–∏—è —Å–∫–ª–∞–¥–∞',
        description: '–†–æ–±–æ—Ç—ã-–≥—Ä—É–∑—á–∏–∫–∏ —Å–æ–±–∏—Ä–∞—é—Ç –∏ —Å–æ—Ä—Ç–∏—Ä—É—é—Ç —Ç–æ–≤–∞—Ä—ã –Ω–∞ —Å–∫–ª–∞–¥–µ',
        subject: '–ò–Ω—Ñ–æ—Ä–º–∞—Ç–∏–∫–∞ / –õ–æ–≥–∏—Å—Ç–∏–∫–∞',
        initialAgents: 10,
        agentType: 'robot',
        setupTargets: () => {
          return Array.from({ length: 20 }, () => ({
            x: Math.random() * 700 + 50,
            y: Math.random() * 500 + 50,
            type: 'box',
            collected: false,
            priority: Math.floor(Math.random() * 3)
          }));
        },
        setupObstacles: () => {
          const obstacles = [];
          for (let i = 0; i < 5; i++) {
            for (let j = 0; j < 3; j++) {
              obstacles.push({
                x: 150 + i * 130,
                y: 100 + j * 180,
                radius: 25,
                width: 80,
                height: 40
              });
            }
          }
          return obstacles;
        },
        successCondition: (stats, targets) => {
          const collected = targets.filter(t => t.collected).length;
          return collected === targets.length;
        },
        hint: '–û–ø—Ç–∏–º–∏–∑–∏—Ä—É–π—Ç–µ –º–∞—Ä—à—Ä—É—Ç—ã: –∏–∑–±–µ–≥–∞–π—Ç–µ —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏–π –∏ –ø–æ–≤—Ç–æ—Ä–Ω–æ–≥–æ –ø–æ—Å–µ—â–µ–Ω–∏—è –∑–æ–Ω'
      },

      ocean_cleanup: {
        name: 'üåä –û—á–∏—Å—Ç–∫–∞ –æ–∫–µ–∞–Ω–∞ –æ—Ç –º—É—Å–æ—Ä–∞',
        description: '–ê–≤—Ç–æ–Ω–æ–º–Ω—ã–µ –∫–∞—Ç–µ—Ä–∞ —Å–æ–±–∏—Ä–∞—é—Ç –ø–ª–∞—Å—Ç–∏–∫–æ–≤—ã–π –º—É—Å–æ—Ä –≤ –æ–∫–µ–∞–Ω–µ',
        subject: '–≠–∫–æ–ª–æ–≥–∏—è / –•–∏–º–∏—è',
        initialAgents: 7,
        agentType: 'boat',
        setupTargets: () => {
          return Array.from({ length: 25 }, () => ({
            x: Math.random() * 700 + 50,
            y: Math.random() * 500 + 50,
            type: 'trash',
            size: Math.random() * 3 + 1,
            collected: false
          }));
        },
        setupObstacles: () => {
          return Array.from({ length: 5 }, () => ({
            x: Math.random() * 800,
            y: Math.random() * 600,
            radius: 30,
            vx: (Math.random() - 0.5) * 0.5,
            vy: (Math.random() - 0.5) * 0.5
          }));
        },
        successCondition: (stats, targets) => {
          const collected = targets.filter(t => t.collected).length;
          return collected >= targets.length * 0.9;
        },
        hint: '–ú—É—Å–æ—Ä –¥—Ä–µ–π—Ñ—É–µ—Ç! –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ "–ü—Ä–µ–¥—Å–∫–∞–∑—ã–≤–∞—Ç—å –¥–≤–∏–∂–µ–Ω–∏–µ" –¥–ª—è —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ–≥–æ —Å–±–æ—Ä–∞'
      },

      crop_monitoring: {
        name: 'üåæ –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ —Å–µ–ª—å—Ö–æ–∑—É–≥–æ–¥–∏–π',
        description: '–î—Ä–æ–Ω—ã —Å–∫–∞–Ω–∏—Ä—É—é—Ç –ø–æ–ª—è, –≤—ã—è–≤–ª—è—è –∑–∞–±–æ–ª–µ–≤–∞–Ω–∏—è —Ä–∞—Å—Ç–µ–Ω–∏–π',
        subject: '–ë–∏–æ–ª–æ–≥–∏—è / –°–µ–ª—å—Å–∫–æ–µ —Ö–æ–∑—è–π—Å—Ç–≤–æ',
        initialAgents: 5,
        agentType: 'agro_drone',
        setupTargets: () => {
          return Array.from({ length: 15 }, () => ({
            x: Math.random() * 700 + 50,
            y: Math.random() * 500 + 50,
            type: 'sick_crop',
            scanned: false,
            severity: Math.random()
          }));
        },
        setupObstacles: () => [],
        successCondition: (stats, targets) => {
          const scanned = targets.filter(t => t.scanned).length;
          return scanned === targets.length && stats.coverage > 85;
        },
        hint: '–†–∞–≤–Ω–æ–º–µ—Ä–Ω–æ–µ –ø–æ–∫—Ä—ã—Ç–∏–µ –≤–∞–∂–Ω–µ–µ —Å–∫–æ—Ä–æ—Å—Ç–∏. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ "–°–µ—Ç–æ—á–Ω–æ–µ —Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ"'
      },

      traffic_control: {
        name: 'üö¶ –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –¥–æ—Ä–æ–∂–Ω—ã–º –¥–≤–∏–∂–µ–Ω–∏–µ–º',
        description: '–ë–µ—Å–ø–∏–ª–æ—Ç–Ω–∏–∫–∏ –∫–æ–æ—Ä–¥–∏–Ω–∏—Ä—É—é—Ç –¥–≤–∏–∂–µ–Ω–∏–µ —Ç—Ä–∞–Ω—Å–ø–æ—Ä—Ç–∞ –Ω–∞ –ø–µ—Ä–µ–∫—Ä—ë—Å—Ç–∫–∞—Ö',
        subject: '–§–∏–∑–∏–∫–∞ / –û–ë–ñ',
        initialAgents: 12,
        agentType: 'car',
        setupTargets: () => {
          return Array.from({ length: 12 }, (_, i) => ({
            x: i < 6 ? 100 : 700,
            y: 100 + (i % 6) * 80,
            type: 'destination',
            reached: false,
            agentId: i
          }));
        },
        setupObstacles: () => {
          return [
            { x: 300, y: 300, radius: 50, type: 'intersection' },
            { x: 500, y: 300, radius: 50, type: 'intersection' }
          ];
        },
        successCondition: (stats, targets) => {
          return targets.filter(t => t.reached).length === targets.length;
        },
        hint: '–ò–∑–±–µ–≥–∞–π—Ç–µ –ø—Ä–æ–±–æ–∫: "–î–µ—Ä–∂–∞—Ç—å –¥–∏—Å—Ç–∞–Ω—Ü–∏—é" + "–û–±—ä–µ–∑–∂–∞—Ç—å —Å–∫–æ–ø–ª–µ–Ω–∏—è"'
      }
    };

    const blockTypes = [
      { id: 'find_nearest_target', name: '–ù–∞–π—Ç–∏ –±–ª–∏–∂–∞–π—à—É—é —Ü–µ–ª—å', color: 'bg-red-500', category: 'action', icon: 'üéØ' },
      { id: 'avoid_obstacles', name: '–ò–∑–±–µ–≥–∞—Ç—å –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏–π', color: 'bg-orange-500', category: 'safety', icon: '‚ö†Ô∏è' },
      { id: 'avoid_others', name: '–ò–∑–±–µ–≥–∞—Ç—å –¥—Ä—É–≥–∏—Ö –∞–≥–µ–Ω—Ç–æ–≤', color: 'bg-orange-600', category: 'safety', icon: '‚áã' },
      { id: 'stay_together', name: '–î–µ—Ä–∂–∞—Ç—å—Å—è –≤–º–µ—Å—Ç–µ', color: 'bg-teal-500', category: 'coordination', icon: '‚óâ' },
      { id: 'spread_out', name: '–†–∞—Å–ø—Ä–µ–¥–µ–ª–∏—Ç—å—Å—è —Ä–∞–≤–Ω–æ–º–µ—Ä–Ω–æ', color: 'bg-teal-600', category: 'coordination', icon: '‚äï' },
      { id: 'grid_scan', name: '–°–µ—Ç–æ—á–Ω–æ–µ —Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ', color: 'bg-blue-500', category: 'movement', icon: '‚ñ¶' },
      { id: 'spiral_search', name: '–°–ø–∏—Ä–∞–ª—å–Ω—ã–π –ø–æ–∏—Å–∫', color: 'bg-blue-600', category: 'movement', icon: 'üåÄ' },
      { id: 'priority_target', name: '–ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç —Å—Ä–æ—á–Ω–æ—Å—Ç–∏', color: 'bg-purple-500', category: 'logic', icon: '‚ö°' },
      { id: 'return_to_base', name: '–í–µ—Ä–Ω—É—Ç—å—Å—è –Ω–∞ –±–∞–∑—É', color: 'bg-green-500', category: 'action', icon: 'üè†' }
    ];

    // –°–æ—Å—Ç–æ—è–Ω–∏–µ —Å–∏–º—É–ª—è—Ü–∏–∏
    let state = {
      isRunning: false,
      selectedTask: 'forest_fire',
      agents: [],
      rules: [],
      targets: [],
      obstacles: [],
      stats: { collected: 0, time: 0, coverage: 0, efficiency: 0, rescued: 0, extinguished: 0 },
      animationRef: null
    };

    const canvas = document.getElementById('simCanvas');
    const ctx = canvas.getContext('2d');

    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞
    function initUI() {
      renderTaskGrid();
      renderBlocksList();
      updateRulesList();
      initializeSimulation();
    }

    function renderTaskGrid() {
      const grid = document.getElementById('taskGrid');
      grid.innerHTML = '';
      Object.entries(tasks).forEach(([key, task]) => {
        const btn = document.createElement('button');
        btn.className = 'swarm-blocks-task-btn' + (state.selectedTask === key ? ' active' : '');
        btn.innerHTML = `
          <div class="swarm-blocks-task-name">${task.name}</div>
          <div class="swarm-blocks-task-subject">${task.subject}</div>
          <div class="swarm-blocks-task-desc">${task.description}</div>
        `;
        btn.onclick = () => {
          state.selectedTask = key;
          state.isRunning = false;
          initializeSimulation();
          renderTaskGrid();
          updateControlButtons();
          draw();
        };
        grid.appendChild(btn);
      });
    }

    function renderBlocksList() {
      const list = document.getElementById('blocksList');
      list.innerHTML = '';
      blockTypes.forEach(block => {
        const btn = document.createElement('button');
        btn.className = `swarm-blocks-block-btn ${block.color}`;
        btn.innerHTML = `
          <span class="swarm-blocks-icon">${block.icon}</span>
          <span class="swarm-blocks-name">${block.name}</span>
          <span class="swarm-blocks-plus">+</span>
        `;
        btn.onclick = () => addRule(block.id);
        list.appendChild(btn);
      });
    }

    function addRule(blockId) {
      state.rules.push({ id: Date.now(), type: blockId, priority: state.rules.length });
      updateRulesList();
    }

    function removeRule(ruleId) {
      state.rules = state.rules.filter(r => r.id !== ruleId);
      updateRulesList();
    }

    function updateRulesList() {
      const list = document.getElementById('rulesList');
      document.getElementById('ruleCount').textContent = state.rules.length;

      if (state.rules.length === 0) {
        list.innerHTML = '<div class="swarm-blocks-empty"><div class="swarm-blocks-empty-icon">‚ö†Ô∏è</div><p>–°–æ—Å—Ç–∞–≤—å—Ç–µ –ø—Ä–æ–≥—Ä–∞–º–º—É –∏–∑ –±–ª–æ–∫–æ–≤</p></div>';
      } else {
        list.innerHTML = '';
        state.rules.forEach((rule, idx) => {
          const block = blockTypes.find(b => b.id === rule.type);
          const div = document.createElement('div');
          div.className = `swarm-blocks-rule-item ${block.color}`;
          div.innerHTML = `
            <div class="swarm-blocks-rule-content">
              <span class="swarm-blocks-icon">${block.icon}</span>
              <span class="swarm-blocks-rule-text">${idx + 1}. ${block.name}</span>
            </div>
            <button class="swarm-blocks-delete-btn">‚úï</button>
          `;
          div.querySelector('.swarm-blocks-delete-btn').onclick = () => removeRule(rule.id);
          list.appendChild(div);
        });
      }

      const task = tasks[state.selectedTask];
      document.getElementById('hint').innerHTML = `üí° ${task.hint}`;
    }

    function initializeSimulation() {
      const task = tasks[state.selectedTask];
      state.agents = Array.from({ length: task.initialAgents }, (_, i) => ({
        id: i,
        x: 100 + (i % 4) * 30,
        y: 100 + Math.floor(i / 4) * 30,
        vx: 0,
        vy: 0,
        color: `hsl(${(i * 360) / task.initialAgents}, 70%, 60%)`,
        hasTarget: false,
        targetId: null
      }));
      state.obstacles = task.setupObstacles();
      state.targets = task.setupTargets();
      state.stats = { collected: 0, time: 0, coverage: 0, efficiency: 0, rescued: 0, extinguished: 0 };

      updateStats();
      draw();
    }

    function applyRules(agent) {
      let dx = 0, dy = 0;

      state.rules.forEach(rule => {
        switch (rule.type) {
          case 'find_nearest_target': {
            const available = state.targets.filter(t => !t.collected && !t.rescued && !t.extinguished && !t.scanned && !t.reached);
            if (available.length > 0) {
              let closest = available[0];
              let minDist = Math.hypot(closest.x - agent.x, closest.y - agent.y);
              available.forEach(t => {
                const dist = Math.hypot(t.x - agent.x, t.y - agent.y);
                if (dist < minDist) {
                  minDist = dist;
                  closest = t;
                }
              });
              dx += (closest.x - agent.x) * 0.004;
              dy += (closest.y - agent.y) * 0.004;
            }
            break;
          }

          case 'avoid_obstacles': {
            state.obstacles.forEach(obs => {
              const dist = Math.hypot(obs.x - agent.x, obs.y - agent.y);
              const safeDistance = (obs.radius || 20) + 30;
              if (dist < safeDistance && dist > 0) {
                const force = (safeDistance - dist) / safeDistance;
                dx -= (obs.x - agent.x) / dist * force * 0.5;
                dy -= (obs.y - agent.y) / dist * force * 0.5;
              }
            });
            break;
          }

          case 'avoid_others': {
            state.agents.forEach(other => {
              if (other.id !== agent.id) {
                const dist = Math.hypot(other.x - agent.x, other.y - agent.y);
                if (dist < 40 && dist > 0) {
                  dx -= (other.x - agent.x) / dist * 0.3;
                  dy -= (other.y - agent.y) / dist * 0.3;
                }
              }
            });
            break;
          }

          case 'stay_together': {
            const avgX = state.agents.reduce((s, a) => s + a.x, 0) / state.agents.length;
            const avgY = state.agents.reduce((s, a) => s + a.y, 0) / state.agents.length;
            dx += (avgX - agent.x) * 0.001;
            dy += (avgY - agent.y) * 0.001;
            break;
          }

          case 'spread_out': {
            state.agents.forEach(other => {
              if (other.id !== agent.id) {
                const dist = Math.hypot(other.x - agent.x, other.y - agent.y);
                const idealDist = 100;
                if (dist < idealDist && dist > 0) {
                  dx -= (other.x - agent.x) / dist * 0.2;
                  dy -= (other.y - agent.y) / dist * 0.2;
                }
              }
            });
            break;
          }

          case 'grid_scan': {
            const gridSize = 80;
            const gridX = Math.floor(agent.x / gridSize) * gridSize + gridSize / 2;
            const gridY = Math.floor(agent.y / gridSize) * gridSize + gridSize / 2;
            const nextGridX = gridX + gridSize;
            dx += (nextGridX - agent.x) * 0.002;
            dy += (nextGridY - agent.y) * 0.002;
            break;
          }

          case 'spiral_search': {
            const centerX = 400;
            const centerY = 300;
            const angle = Math.atan2(agent.y - centerY, agent.x - centerX);
            const radius = Math.hypot(agent.x - centerX, agent.y - centerY);
            dx += Math.cos(angle + 0.1) * 0.3 + (centerX - agent.x) * 0.0001 * radius;
            dy += Math.sin(angle + 0.1) * 0.3 + (centerY - agent.y) * 0.0001 * radius;
            break;
          }

          case 'priority_target': {
            const urgent = state.targets.filter(t => (t.urgent || t.priority === 0) && !t.collected && !t.rescued && !t.extinguished);
            if (urgent.length > 0) {
              const target = urgent[0];
              dx += (target.x - agent.x) * 0.006;
              dy += (target.y - agent.y) * 0.006;
            }
            break;
          }

          case 'return_to_base': {
            const baseX = 100, baseY = 100;
            const dist = Math.hypot(baseX - agent.x, baseY - agent.y);
            if (dist > 50) {
              dx += (baseX - agent.x) * 0.002;
              dy += (baseY - agent.y) * 0.002;
            }
            break;
          }
        }
      });

      return { dx, dy };
    }

    function animate() {
      if (!state.isRunning) return;

      const task = tasks[state.selectedTask];

      // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –¥–≤–∏–∂—É—â–∏—Ö—Å—è –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏–π
      if (state.selectedTask === 'ocean_cleanup') {
        state.obstacles.forEach(obs => {
          if (obs.vx !== undefined) {
            obs.x += obs.vx;
            obs.y += obs.vy;
            if (obs.x < 0 || obs.x > 800) obs.vx *= -1;
            if (obs.y < 0 || obs.y > 600) obs.vy *= -1;
          }
        });
      }

      // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∞–≥–µ–Ω—Ç–æ–≤
      state.agents = state.agents.map(agent => {
        const { dx, dy } = applyRules(agent);
        let newVx = agent.vx * 0.95 + dx;
        let newVy = agent.vy * 0.95 + dy;

        const speed = Math.hypot(newVx, newVy);
        const maxSpeed = 3;
        if (speed > maxSpeed) {
          newVx = (newVx / speed) * maxSpeed;
          newVy = (newVy / speed) * maxSpeed;
        }

        let newX = agent.x + newVx;
        let newY = agent.y + newVy;

        if (newX < 20 || newX > 780) newVx *= -0.8;
        if (newY < 20 || newY > 580) newVy *= -0.8;

        newX = Math.max(20, Math.min(780, newX));
        newY = Math.max(20, Math.min(580, newY));

        return { ...agent, x: newX, y: newY, vx: newVx, vy: newVy };
      });

      // –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è —Ü–µ–ª–µ–π
      let collected = 0;
      state.targets.forEach(target => {
        if (!target.collected && !target.rescued && !target.extinguished && !target.scanned && !target.reached) {
          state.agents.forEach(agent => {
            const dist = Math.hypot(target.x - agent.x, target.y - agent.y);
            if (dist < 20) {
              if (target.type === 'fire') {
                target.intensity -= 10;
                if (target.intensity <= 0) {
                  target.extinguished = true;
                  collected++;
                }
              } else if (target.type === 'person') {
                target.rescued = true;
                collected++;
              } else if (target.type === 'box' || target.type === 'trash') {
                target.collected = true;
                collected++;
              } else if (target.type === 'sick_crop') {
                target.scanned = true;
                collected++;
              } else if (target.type === 'destination' && target.agentId === agent.id) {
                target.reached = true;
                collected++;
              }
            }
          });
        }
      });

      const coverage = Math.min(100, (state.stats.time / 10) + collected * 2);
      const totalCompleted = state.targets.filter(t => t.collected || t.rescued || t.extinguished || t.scanned || t.reached).length;

      state.stats.time += 1;
      state.stats.collected = totalCompleted;
      state.stats.coverage = coverage;
      state.stats.efficiency = totalCompleted / (state.stats.time / 60 + 1) * 10;

      updateStats();
      draw();

      state.animationRef = requestAnimationFrame(animate);
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // –ë–∞–∑–∞
      ctx.fillStyle = 'rgba(0, 255, 0, 0.2)';
      ctx.fillRect(70, 70, 80, 80);
      ctx.strokeStyle = '#00ff00';
      ctx.lineWidth = 2;
      ctx.strokeRect(70, 70, 80, 80);

      // –ü—Ä–µ–ø—è—Ç—Å—Ç–≤–∏—è
      state.obstacles.forEach(obs => {
        if (obs.width && obs.height) {
          ctx.fillStyle = 'rgba(100, 100, 100, 0.5)';
          ctx.fillRect(obs.x - obs.width / 2, obs.y - obs.height / 2, obs.width, obs.height);
        } else {
          ctx.fillStyle = obs.vx !== undefined ? 'rgba(50, 150, 200, 0.3)' : 'rgba(100, 100, 100, 0.4)';
          ctx.beginPath();
          ctx.arc(obs.x, obs.y, obs.radius || 20, 0, Math.PI * 2);
          ctx.fill();
        }
      });

      // –¶–µ–ª–∏
      state.targets.forEach(target => {
        const completed = target.collected || target.rescued || target.extinguished || target.scanned || target.reached;

        if (target.type === 'fire') {
          ctx.fillStyle = target.extinguished ? 'rgba(100, 100, 100, 0.5)' : `rgba(255, ${255 - target.intensity * 2}, 0, 0.8)`;
          ctx.beginPath();
          ctx.arc(target.x, target.y, 12, 0, Math.PI * 2);
          ctx.fill();
        } else if (target.type === 'person') {
          ctx.fillStyle = target.rescued ? 'rgba(0, 255, 0, 0.5)' : (target.urgent ? '#ff0000' : '#ffff00');
          ctx.beginPath();
          ctx.arc(target.x, target.y, 8, 0, Math.PI * 2);
          ctx.fill();
        } else if (target.type === 'box') {
          if (!completed) {
            ctx.fillStyle = target.priority === 0 ? '#ff6600' : target.priority === 1 ? '#ffaa00' : '#ffdd00';
            ctx.fillRect(target.x - 6, target.y - 6, 12, 12);
          }
        } else if (target.type === 'trash') {
          if (!completed) {
            ctx.fillStyle = '#00aa00';
            ctx.beginPath();
            ctx.arc(target.x, target.y, target.size * 3, 0, Math.PI * 2);
            ctx.fill();
          }
        } else if (target.type === 'sick_crop') {
          ctx.fillStyle = target.scanned ? 'rgba(0, 255, 0, 0.3)' : 'rgba(139, 69, 19, 0.6)';
          ctx.fillRect(target.x - 8, target.y - 8, 16, 16);
        } else if (target.type === 'destination') {
          ctx.fillStyle = target.reached ? 'rgba(0, 255, 0, 0.5)' : 'rgba(0, 100, 255, 0.5)';
          ctx.beginPath();
          ctx.arc(target.x, target.y, 15, 0, Math.PI * 2);
          ctx.fill();
        }
      });

      // –ê–≥–µ–Ω—Ç—ã
      state.agents.forEach(agent => {
        ctx.fillStyle = agent.color;
        ctx.beginPath();
        ctx.arc(agent.x, agent.y, 8, 0, Math.PI * 2);
        ctx.fill();

        ctx.strokeStyle = agent.color;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(agent.x, agent.y);
        ctx.lineTo(agent.x + agent.vx * 5, agent.y + agent.vy * 5);
        ctx.stroke();
      });
    }

    function updateStats() {
      document.getElementById('agentCount').textContent = state.agents.length;
      document.getElementById('collectedCount').textContent = state.stats.collected;
      document.getElementById('totalCount').textContent = state.targets.length;
      document.getElementById('coverageValue').textContent = Math.floor(state.stats.coverage);
      document.getElementById('timeValue').textContent = Math.floor(state.stats.time / 60);

      const task = tasks[state.selectedTask];
      const isSuccess = task.successCondition(state.stats, state.targets);

      const successMsg = document.getElementById('successMsg');
      if (isSuccess && state.stats.time > 0) {
        successMsg.style.display = 'flex';
        document.getElementById('successStats').textContent = `–≠—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ—Å—Ç—å: ${state.stats.efficiency.toFixed(1)} ‚Ä¢ –í—Ä–µ–º—è: ${Math.floor(state.stats.time / 60)}—Å`;
      } else {
        successMsg.style.display = 'none';
      }
    }

    function updateControlButtons() {
      const playBtn = document.getElementById('playBtn');
      const pauseBtn = document.getElementById('pauseBtn');
      if (state.isRunning) {
        playBtn.style.display = 'none';
        pauseBtn.style.display = 'flex';
      } else {
        playBtn.style.display = 'flex';
        pauseBtn.style.display = 'none';
      }
    }

    // –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –∫–Ω–æ–ø–æ–∫
    document.getElementById('playBtn').addEventListener('click', () => {
      state.isRunning = true;
      updateControlButtons();
      animate();
    });

    document.getElementById('pauseBtn').addEventListener('click', () => {
      state.isRunning = false;
      if (state.animationRef) cancelAnimationFrame(state.animationRef);
      updateControlButtons();
    });

    document.getElementById('resetBtn').addEventListener('click', () => {
      state.isRunning = false;
      if (state.animationRef) cancelAnimationFrame(state.animationRef);
      initializeSimulation();
      updateControlButtons();
    });

    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
    initUI();
  </script>
</body>
</html>
